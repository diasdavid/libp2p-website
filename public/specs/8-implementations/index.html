<!DOCTYPE html>
<html lang="en-US">

<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

  	<meta property="og:title" content=" 8 Implementations &middot;  libp2p" />
  	<meta property="og:site_name" content="libp2p" />
  	<meta property="og:url" content="/specs/8-implementations/" />
    
    
  	<meta property="og:type" content="article" />

    <meta property="og:article:published_time" content="0001-01-01T00:00:00Z" />

    
    

  <title>
     8 Implementations &middot;  libp2p
  </title>

    <meta name="description" content="make peer-to-peer great again" />

    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="shortcut icon" href="images/favicon.ico">
	  <link rel="apple-touch-icon" href="images/apple-touch-icon.png" />
    
    <link rel="stylesheet" type="text/css" href="../../css/screen.css" />
    <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Merriweather:300,700,700italic,300italic|Open+Sans:700,400|Inconsolata" />


    
      
          <link href="index.xml" rel="alternate" type="application/rss+xml" title="libp2p" />
      
      
    
    <meta name="generator" content="Hugo 0.16" />

    <link rel="canonical" href="../../specs/8-implementations/" />

    
<div id="particles-js"></div>
<script src="https://cdn.jsdelivr.net/particles.js/2.0.0/particles.min.js"></script>
<script src="../../js/particles.js"></script>
</head>
<body class="nav-closed">

  <div class="nav">
    <h3 class="nav-title">Menu</h3>
    <a href="#" class="nav-close">
        <span class="hidden">Close</span>
    </a>
    <ul>
        
        
    </ul>

</div>
<span class="nav-cover"></span>


 <div class="site-wrapper">


<header class="main-header " style="background-image: url(images/user.jpg)">

    <nav class="main-nav overlay clearfix">
        
    </nav>
<div class="vertical">
        <div class="main-header-content inner">
            <h1 class="page-title">
              <a class="btn-bootstrap-2" href="../../">libp2p</a>
          </h1>
          <h2 class="page-description">make peer-to-peer great again</h2>
        </div>
</div>
    <a class="scroll-down icon-arrow-left" href="#content"><span class="hidden">Scroll Down</span></a>
</header>

  <main id="content" class="content" role="main">


  <article class="post specs">

    <header class="post-header">
        <h1 class="post-title">8 Implementations</h1>
        <section class="post-meta">
        
         
        </section>
    </header>

    <section class="post-content">
      

<p>A <code>libp2p</code> implementation should (recommended) follow a certain level of granulatiry when implementing different modules and functionalities, so that common interfaces are easy to expose, test and check for interoperability with other implementations.</p>

<p>This is the list of current modules available for <code>libp2p</code>:</p>

<ul>
<li>libp2p (entry point)</li>
<li><strong>Swarm</strong>

<ul>
<li>libp2p-swarm</li>
<li>libp2p-identify</li>
<li>libp2p-ping</li>
<li>Transports

<ul>
<li><a href="https://github.com/diasdavid/interface-transport">interface-transport</a></li>
<li><a href="https://github.com/diasdavid/interface-connection">interface-connection</a></li>
<li>libp2p-tcp</li>
<li>libp2p-udp</li>
<li>libp2p-udt</li>
<li>libp2p-utp</li>
<li>libp2p-webrtc</li>
<li>libp2p-cjdns</li>
</ul></li>
<li>Stream Muxing

<ul>
<li><a href="https://github.com/diasdavid/interface-stream-muxer">interface-stream-muxer</a></li>
<li>libp2p-spdy</li>
<li>libp2p-multiplex</li>
</ul></li>
<li>Crypto Channel

<ul>
<li>libp2p-tls</li>
<li>libp2p-secio</li>
</ul></li>
</ul></li>
<li><strong>Peer Routing</strong>

<ul>
<li>libp2p-kad-routing</li>
<li>libp2p-mDNS-routing</li>
</ul></li>
<li><strong>Discovery</strong>

<ul>
<li>libp2p-mdns-discovery</li>
<li>libp2p-random-walk</li>
<li>libp2p-railing</li>
</ul></li>
<li><strong>Distributed Record Store</strong>

<ul>
<li>libp2p-record</li>
<li><a href="https://github.com/diasdavid/interface-record-store">interface-record-store</a></li>
<li>libp2p-distributed-record-store</li>
<li>libp2p-kad-record-store</li>
</ul></li>
<li><strong>Generic</strong>

<ul>
<li>PeerInfo</li>
<li>PeerId</li>
<li>multihash</li>
<li>multiaddr</li>
<li>multistream</li>
<li>multicodec</li>
<li>ipld</li>
<li>repo</li>
</ul></li>
</ul>

<p>Current known implementations (or WIP) are:</p>

<ul>
<li>JavaScript - <a href="https://github.com/diasdavid/js-libp2p">https://github.com/diasdavid/js-libp2p</a></li>
<li>Go - <a href="https://github.com/ipfs/go-libp2p">https://github.com/ipfs/go-libp2p</a></li>
<li>Python - <a href="https://github.com/candeira/py-ipfs/blob/readme-roadmap/README.md">https://github.com/candeira/py-ipfs/blob/readme-roadmap/README.md</a></li>
<li>Rust - <a href="https://github.com/diasdavid/rust-libp2p">https://github.com/diasdavid/rust-libp2p</a></li>
</ul>

<h2 id="8-1-swarm">8.1 Swarm</h2>

<h3 id="8-1-1-swarm-dialer">8.1.1 Swarm Dialer</h3>

<p>The swarm dialer manages making a successful connection to a target peer, given a stream of addresses as inputs, and making sure to respect any and all rate limits imposed. To this end, we have designed the following logic for dialing:</p>

<pre><code>DialPeer(peerID) {
	if PeerIsBeingDialed(peerID) {
		waitForDialToComplete(peerID)
		return BestConnToPeer(peerID)
	}
	
	StartDial(peerID)

	waitForDialToComplete(peerID)
	return BestConnToPeer(peerID)
}

	
StartDial(peerID) {
	addrs = getAddressStream(peerID)

	addrs.onNewAddr(function(addr) {
		if rateLimitCanDial(peerID, addr) {
			doDialAsync(peerID, addr)
		} else {
			rateLimitScheduleDial(peerID, addr)
		}
	})
}

// doDialAsync starts dialing to a specific address without blocking.
// when the dial returns, it releases rate limit tokens, and if it
// succeeded, will finalize the dial process.
doDialAsync(peerID, addr) {
	go transportDial(addr, function(conn, err) {
		rateLimitReleaseTokens(peerID, addr)

		if err != null {
			// handle error
		}

		dialSuccess(conn)
	})
}

// rateLimitReleaseTokens checks for any tokens the given dial
// took, and then for each of them, checks if any other dial is waiting
// for any of those tokens. If waiting dials are found, those dials are started
// immediately. Otherwise, the tokens are released to their pools.
rateLimitReleaseTokens(peerID, addr) {
	tokens = tokensForDial(peerID, addr)

	for token in tokens {
		dial = dialWaitingForToken(token)
		if dial != null {
			doDialAsync(dial.peer, dial.addr)
		} else {
			token.release()
		}
	}
	
}
</code></pre>

    </section>

</article>

</main>
    <footer class="site-footer clearfix">
        <section class="copyright"><a href="">libp2p</a> All rights reserved - 2016</section>
        
        <section class="poweredby">Proudly generated by <a class="icon-hugo" href="https://gohugo.io">HUGO</a>, with <a class="icon-theme" href="https://github.com/syui/hugo-theme-air">hugo-theme-air</a> theme</section>
        
    </footer>
    </div>
    <script type="text/javascript" src="../../js/jquery.js"></script>
    <script type="text/javascript" src="../../js/jquery.fitvids.js"></script>
    <script type="text/javascript" src="../../js/index.js"></script>

</body>
</html>

